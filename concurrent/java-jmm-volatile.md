#### java 高并发的三大特性：

- 可见性
- 原子性
- 有序性

那么在JVM的并发包中实现上面三种特性的

- volatile: 只有可见性, 有序性
	- 可见性通过MESI实现
	- 有序性用happens-before规则，禁止指令重排。
- synchronized: 有可见性，原子性
	- 可见性，JMM关于synchronized的两条规定：1）线程解锁前，必须把共享变量的最新值刷新到主内存中，2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值
	- 原子性 互斥锁

- ReentrantLock: 有可见性，原子性
	- 可见性 和synchronized一样
	- 原子性 也是锁实现的

- Atomic: 原子性，可见性
	
![][1]
![][2]

为了屏蔽各种处理器的缓存操作指令，jvm弄了8个原子操作。屏蔽各种处理器各种操作系统的。
![][3]

![][4]

### volatile汇编底层原理

![][5]

```
public class Test {
    private volatile int a;
    public void update() {
        a = 1;
    }
    public static void main(String[] args) {
        Test test = new Test();
        test.update();
    }
}
```

```

......
  0x0000000002951563: and    $0xffffffffffffff87,%rdi
  0x0000000002951567: je     0x00000000029515f8
  0x000000000295156d: test   $0x7,%rdi
  0x0000000002951574: jne    0x00000000029515bd
  0x0000000002951576: test   $0x300,%rdi
  0x000000000295157d: jne    0x000000000295159c
  0x000000000295157f: and    $0x37f,%rax
  0x0000000002951586: mov    %rax,%rdi
  0x0000000002951589: or     %r15,%rdi
  0x000000000295158c: lock cmpxchg %rdi,(%rdx)  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令
  0x0000000002951591: jne    0x0000000002951a15
  0x0000000002951597: jmpq   0x00000000029515f8
  0x000000000295159c: mov    0x8(%rdx),%edi
  0x000000000295159f: shl    $0x3,%rdi
  0x00000000029515a3: mov    0xa8(%rdi),%rdi
  0x00000000029515aa: or     %r15,%rdi
......
```

- lock 前缀的指令在多核处理器下会引发两件事情。

	- 1）将当前处理器缓存行的数据写回到系统内存。
	- 2）写回内存的操作会使在其他 CPU 里缓存了该内存地址的额数据无效。

- 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2 或其他）后再进行操作，但操作完不知道何时会写到内存。
- 如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。
- 为了保证各个处理器的缓存是一致的，实现了缓存一致性协议（MESI），每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
	- 所有多核处理器下还会完成：3）当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。
- volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。

#### lock指令和可见性
- 在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。
- 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。
	-	因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。
	-	这种场景多缓存的数据一致通过缓存一致性协议（MESI）来保证。见附录


#### 有序性保证

- happens-before规则定义：

	- 根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。
根据程序次序规则：1 happens-before 2 且 3 happens-before 4。
	- 根据 volatile 规则：2 happens-before 3。
	- 根据 happens-before 的传递性规则：1 happens-before 4。

- 禁止指令重排

| 第一个操作 | 第二个操作：普通读/写 | 第二个操作：volatile读 | 第二个操作：volatile写 |
| ------ | ------ | ------ | ------ |
| 普通读/写 | 可以被重新排序 | 可以被重新排序 | 禁止指令重排 |
| volatile读 | 禁止指令重排 | 禁止指令重排 | 禁止指令重排 |
| volatile写 | 可以被重新排序 | 禁止指令重排 | 禁止指令重排 |


- 为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。
- 对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。
	- 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。
	- 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。
	- 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。
	- 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。
- volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障


| 内存屏障	 | 说明 |
| ------ | ------ |
| StoreStore 屏障	 | 禁止上面的普通写和下面的 volatile 写重排序。 |
| StoreLoad 屏障	 | 防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。 |
| LoadLoad 屏障	 | 禁止下面所有的普通读操作和上面的 volatile 读重排序。 |
| LoadStore 屏障		 | 禁止下面所有的普通写操作和上面的 volatile 读重排序。 |

![][7]
![][8]

#### 附录1 缓存一致性协议

设计缓存一致性协议的目的： 缓存是被CPU独占的，但是内存是被CPU共享的，如何在修改独占资源的时候，其他核的CPU及时感知到？ 经常想到的就是给总线加互斥锁，但是粒度太大，导致其他CPU假死。所以缓存一致性协议产生了，通过
-	所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。
-	缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（同一个指令周期中，只有一个 CPU 缓存可以读写内存）。
-	CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。
-	当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。
	- 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。
<br>

CPU中每个缓存行（caceh line)使用4种状态进行标记（使用额外的两位(bit)表示):<br>

- M: 被修改（Modified)
	- 该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。
- E: 独享的（Exclusive)
	- 该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。
- S: 共享的（Shared)
	- 该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））
- I: 无效的（Invalid）
	- 该缓存是无效的（可能有其它CPU修改了该缓存行）

状态转变
![][6]

- 一个缓存除在Invalid状态外都可以满足cpu的读请求，一个Invalid的缓存行必须从主存中读取（变成S或者 E状态）来满足该CPU的读请求
- 一个写请求只有在该缓存行是M或者E状态时才能被执行，如果缓存行处于S状态，必须先将其它缓存中该缓存行变成Invalid状态（也既是不允许不同CPU同时修改同一缓存行，即使修改该缓存行中不同位置的数据也不允许）。该操作经常作用广播的方式来完成，例如：RequestFor Ownership (RFO)
- 缓存可以随时将一个非M状态的缓存行作废，或者变成Invalid状态，而一个M状态的缓存行必须先被写回主存。一个处于M状态的缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S状态之前被延迟执行
- 一个处于S状态的缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。
- 一个处于E状态的缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S状态
- 对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的。而S状态可能是非一致的，如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经

- 独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。

从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成Invalid状态，而修改E状态的缓存不需要使用总线事务


[1]: ../images/concurrent/jmm-volatile.png
[2]: ../images/concurrent/java-jmm-cpu-mem.jpg
[3]: ../images/concurrent/jvm-cpu-atomic.jpg
[4]: ../images/concurrent/jmm-atomic-1.jpg
[5]: ../images/concurrent/jmm-volatile-1.jpg
[6]: ../images/concurrent/MESI.png
[7]: ../images/concurrent/jvm-volatile-barrer.png
[8]: ../images/concurrent/jvm-volatile-barrer2.png